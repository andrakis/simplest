// App wrapper start
var modules = {}, ref;

var start_time = +new Date();

orig_require = require;
var obtain = function(path) {
	if (0) console.log("obtain(" + path + ")");
	for(key in modules)
		if (0) console.log("  have: '" + key + "'");
	if (0) console.log("Match is ", modules[path], path in modules);
	if( modules[path] ) {
		if (0) console.log("found, returning: ", modules[path]);
		return modules[path];
	} else {
		if (0) console.log("not found, using require");
		return orig_require(path);
	}
};

require = obtain;

if (typeof web_console != 'undefined') {
	console = web_console;
}


// Wrap.js, for symbols
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for symbols");

// Generated by CoffeeScript 1.4.0
(function() {
  var decSymbol, defSymbol, definition_cache, exports, getSymbol, getSymbols,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  definition_cache = {};

  defSymbol = function(name, value) {
    if (__indexOf.call(definition_cache, name) >= 0) {
      throw "symbol already registered";
    }
    return definition_cache[name] = value;
  };

  decSymbol = function(name, value) {
    if (__indexOf.call(definition_cache, name) >= 0 && definition_cache[name] !== value) {
      throw "redefinition of " + name + " to " + value;
    }
    return definition_cache[name] = value;
  };

  getSymbol = function(name) {
    return definition_cache[name];
  };

  getSymbols = function() {
    return definition_cache;
  };

  exports = module.exports = {
    defSymbol: defSymbol,
    decSymbol: decSymbol,
    getSymbol: getSymbol,
    getSymbols: getSymbols
  };

}).call(this);

// Wrap_post.js, for symbols
	return exports;
});

if( modules ) {
	if (0) console.log("Registering symbols");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from symbols");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['symbols'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered symbols as", modules['symbols']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for tc_util
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for tc_util");

// Generated by CoffeeScript 1.4.0
(function() {
  var clone;

  exports.charCode = function(S) {
    return ("" + S).charCodeAt(0);
  };

  clone = function(obj) {
    var key, temp;
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    temp = new obj.constructor();
    for (key in obj) {
      temp[key] = clone(obj[key]);
    }
    return temp;
  };

  exports.clone = clone;

  exports.StackTrace = function() {
    var err;
    err = new Error;
    return err.stack;
  };

  exports.DumpObjectFlat = function(obj) {
    var len, od, ood, property, result, value;
    od = new Object;
    result = '';
    len = 0;
    for (property in obj) {
      value = obj[property];
      if (typeof value === 'string') {
        console.log('type is string');
        value = '\'' + value + '\'';
      } else if (typeof value === 'object') {
        console.log('value is object');
        if (value instanceof Array) {
          value = '[ ' + value + ' ]';
        } else {
          ood = exports.DumpObjectFlat(value);
          value = '{ ' + ood.dump + ' }';
        }
      }
      result += '\'' + property + '\' : ' + value + ', ';
      len++;
    }
    od.dump = result.replace(/, $/, '');
    od.len = len;
    return od;
  };

  module.exports = exports;

}).call(this);

// Wrap_post.js, for tc_util
	return exports;
});

if( modules ) {
	if (0) console.log("Registering tc_util");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from tc_util");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['tc_util'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered tc_util as", modules['tc_util']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for verbosity
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for verbosity");

// Generated by CoffeeScript 1.4.0
(function() {
  var SETTINGS_VERB, decSymbol, exports, settings, vlog;

  decSymbol = require('symbols').decSymbol;

  SETTINGS_VERB = decSymbol('SETTINGS_VERB', 'verbosity');

  settings = {};

  vlog = function() {
    var args, verbosity;
    args = Array.prototype.slice.call(arguments);
    verbosity = args.shift();
    if (settings[SETTINGS_VERB] >= verbosity) {
      args.unshift("(V-" + verbosity + ")");
      console.log.apply(console, args);
      true;
    }
    return false;
  };

  exports = module.exports = {
    vlog: vlog,
    setVerbosity: function(v) {
      return settings[SETTINGS_VERB] = v;
    },
    getVerbosity: function() {
      return settings[SETTINGS_VERB] || 0;
    }
  };

  exports.setVerbosity(process.env.TINY_VERB || 10);

}).call(this);

// Wrap_post.js, for verbosity
	return exports;
});

if( modules ) {
	if (0) console.log("Registering verbosity");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from verbosity");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['verbosity'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered verbosity as", modules['verbosity']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for tinycpu
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for tinycpu");

// Generated by CoffeeScript 1.4.0
(function() {
  var TinyCPU, decSymbol, ex, exports, vlog;

  vlog = require('verbosity').vlog;

  decSymbol = require('symbols').decSymbol;

  TinyCPU = (function() {

    function TinyCPU() {
      this.memory = {};
      this.registers = {};
      this.register_count = 0;
    }

    TinyCPU.prototype.initialize = function() {
      vlog(100, 'CPU initialize');
      this.abs0 = this.defReg('abs0');
      this.sp = this.defReg('sp');
      this.psp = this.defReg('psp');
      this.cp = this.defReg('cp');
      this.ac = this.defReg('ac');
      this.dc = this.defReg('dc');
      this.opsz = this.defReg('opsz');
      this.eq0 = this.defReg('eq0');
      this.mt0 = this.defReg('mt0');
      this.lt0 = this.defReg('lt0');
      this.r1 = this.defReg('r1');
      this.r2 = this.defReg('r2');
      this.new_stack(0);
      vlog(100, "Writing opsize 3 to " + this.opsz);
      return this.opsize = this.write(this.opsz, 3);
    };

    TinyCPU.prototype.defReg = function(name) {
      var pos;
      vlog(100, "Defining register " + name);
      pos = this.register_count++;
      this.registers[name] = pos;
      this.registers[pos] = name;
      decSymbol(name, pos);
      return pos;
    };

    TinyCPU.prototype.load = function(loc, data) {
      vlog(100, "Loading " + data.length + " bytes into " + loc);
      for (var i = 0; i < data.length; i++, loc++) this.write(loc, data[i]);

    };

    TinyCPU.prototype.new_stack = function(start, psp) {
      var i, offset, _i, _ref;
      vlog(100, "Creating new stack at " + start);
      offset = 0;
      for (i = _i = 0, _ref = this.register_count; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.write(start + offset++, 0);
      }
      this.write(start + this.psp, psp || 0);
      this.write(start + this.abs0, -start);
    };

    TinyCPU.prototype.read = function(loc) {
      return this.memory[loc] || 0;
    };

    TinyCPU.prototype.write = function(loc, value) {
      return this.memory[loc] = value || 0;
    };

    TinyCPU.prototype.enable_debug = function(enable) {
      var self;
      self = this;
      return (function(read, write) {
        if (!enable) {
          self.read = read;
          return self.write = write;
        } else {
          self.read = function(loc) {
            var v;
            v = read.call(self, loc);
            vlog(70, "cpu.read(", loc, ") = ", v);
            return v;
          };
          return self.write = function(loc, value) {
            var prev;
            prev = read.call(self, loc);
            vlog(70, "cpu.write(", loc, ", ", value, ") prev=", prev);
            return write.call(self, loc, value);
          };
        }
      })(self.read, self.write);
    };

    TinyCPU.prototype.cycle = function() {
      return this.fetch();
    };

    TinyCPU.prototype.fetch = function() {
      var add, cp, dst, sp, src;
      sp = this.read(this.sp);
      cp = this.read(sp + this.cp);
      src = this.read(cp);
      add = this.read(cp + 1);
      dst = this.read(cp + 2);
      vlog(20, "Fetch, sp=", sp, ", cp=", cp, ", src=", this.registers[src - sp] || src, "add=", add, "dst=", this.registers[dst - sp] || dst);
      return this.execute(sp, src, add, dst);
    };

    TinyCPU.prototype.execute = function(sp, src, add, dst) {
      var opsz, val;
      vlog(40, "execute(", [sp, src, add, dst].join(', '), ")");
      vlog(60, "(sp=", sp, ")", this.registers[src - sp] || src, " + ", add, "->", this.registers[dst - sp] || dst);
      val = this.write(dst, this.read(src) + add);
      opsz = this.read(sp + this.opsz);
      vlog(90, "Updating cp by " + opsz + "...");
      this.write(sp + this.cp, this.read(sp + this.cp) + opsz);
      vlog(90, "Cp is now ", this.read(sp + this.cp));
      return this.update_flags(sp, val);
    };

    TinyCPU.prototype.update_flags = function(sp, val) {
      this.write(sp + this.ac, this.read(sp + this.ac) + val);
      this.write(sp + this.dc, this.read(sp + this.dc) - val);
      this.write(this.eq0, val === 0 ? this.opsize : 0);
      this.write(this.mt0, val > 0 ? this.opsize : 0);
      this.write(this.lt0, val < 0 ? this.opsize : 0);
      return val;
    };

    return TinyCPU;

  })();

  decSymbol('TinyCPU', TinyCPU);

  exports = ex = module.exports = {
    TinyCPU: TinyCPU
  };

  decSymbol('TinyCPU.exports', ex);

}).call(this);

// Wrap_post.js, for tinycpu
	return exports;
});

if( modules ) {
	if (0) console.log("Registering tinycpu");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from tinycpu");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['tinycpu'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered tinycpu as", modules['tinycpu']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/feature_options
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/feature_options");

// Generated by CoffeeScript 1.4.0
(function() {
  var FeatureOption, FeatureOptionStub, IntegerOption, IntegerRangeOption, StringOption,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  FeatureOption = (function() {

    function FeatureOption(name, _default) {
      this.name = name;
      this.value = this["default"] = _default;
      this.binds = {};
    }

    FeatureOption.prototype["export"] = function(res) {
      res = res || {};
      res[this.name] = this.value;
      return res;
    };

    FeatureOption.prototype.getValue = function() {
      return this.value;
    };

    FeatureOption.prototype.setValue = function(value) {
      var res;
      res = this.fire_bind('set', this.value, value);
      return this.value = res;
    };

    FeatureOption.prototype.bind = function(event, callback) {
      this.binds[event] = this.binds[event] || [];
      this.binds[event].push(callback);
      return true;
    };

    FeatureOption.prototype.fire_bind = function(event, old_value, new_value) {
      var callback, next_res, res, _i, _len, _ref;
      if (this.binds[event] === void 0) {
        return new_value;
      }
      res = new_value;
      _ref = this.binds[event];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        next_res = callback(new_value, old_value);
        if (next_res !== void 0) {
          res = next_res;
        }
      }
      return res;
    };

    FeatureOption.prototype.createHtml = function(jQuery) {
      return jQuery("<span class='option'>There are no options for this feature</span>");
    };

    FeatureOption.prototype.createContainer = function(jQuery) {
      return jQuery("<span class='option' />");
    };

    FeatureOption.prototype.createLabel = function(text, childElements, jQuery) {
      var ele, label, _i, _len;
      label = jQuery("<label/>");
      label.text(text);
      if (childElements == null) {
        return label;
      }
      if (typeof childElements !== []) {
        childElements = [childElements];
      }
      for (_i = 0, _len = childElements.length; _i < _len; _i++) {
        ele = childElements[_i];
        label.append(childElements);
      }
      return label;
    };

    FeatureOption.prototype.createInput = function(jQuery) {
      return jQuery("<input class='option' />");
    };

    return FeatureOption;

  })();

  exports.FeatureOption = FeatureOption;

  StringOption = (function(_super) {

    __extends(StringOption, _super);

    function StringOption(name, _default) {
      StringOption.__super__.constructor.call(this, name, _default);
    }

    StringOption.prototype.createHtml = function(jQuery) {
      var input, self;
      input = this.createInput(jQuery);
      self = this;
      input.change(function() {
        self.setValue(jQuery(this).attr('value'));
      });
      return this.createContainer().append(this.createLabel(this.name, input, jQuery));
    };

    return StringOption;

  })(FeatureOption);

  exports.StringOption = StringOption;

  IntegerOption = (function(_super) {

    __extends(IntegerOption, _super);

    function IntegerOption(name, _default, options) {
      IntegerOption.__super__.constructor.call(this, name, _default);
      options = options || {};
      this.min = options.min || NaN;
      this.max = options.max || NaN;
    }

    IntegerOption.prototype.createHtml = function(jQuery) {
      var input;
      input = this.createInput(jQuery);
      input.attr('type', 'number');
      input.change(function() {
        return self.setValue(jQuery(this).attr('value'));
      });
      return this.createContainer().append(this.createLabel(this.name, input, jQuery));
    };

    return IntegerOption;

  })(FeatureOption);

  exports.IntegerOption = IntegerOption;

  IntegerRangeOption = (function(_super) {

    __extends(IntegerRangeOption, _super);

    function IntegerRangeOption(name, start, end) {
      IntegerRangeOption.__super__.constructor.call(this, name, this.makeRange(start, end));
    }

    IntegerRangeOption.prototype.makeRange = function(start, end) {
      return [start, end];
    };

    IntegerRangeOption.prototype.createHtml = function(jQuery) {
      var change, container, end, self, start;
      start = IntegerRangeOption.__super__.createHtml.call(this, jQuery);
      end = IntegerRangeOption.__super__.createHtml.call(this, jQuery);
      start.unbind('change');
      end.unbind('change');
      self = this;
      change = function() {
        return self.setValue([start.attr('value', end.attr('value'))]);
      };
      container = this.createContainer();
      container.append(this.createLabel('Start', start, jQuery));
      container.append(this.createLabel('End', end, jQuery));
      return container;
    };

    return IntegerRangeOption;

  })(IntegerOption);

  exports.IntegerRangeOption = IntegerRangeOption;

  FeatureOptionStub = (function(_super) {

    __extends(FeatureOptionStub, _super);

    function FeatureOptionStub(name, _default, message) {
      FeatureOptionStub.__super__.constructor.call(this, name, _default);
      this.message = message;
    }

    FeatureOptionStub.prototype.createHtml = function(jQuery) {
      var message;
      message = this.message || ("" + name + " cannot be set via this method");
      return this.createContainer().append(this.createLabel(music, null, jQuery));
    };

    return FeatureOptionStub;

  })(FeatureOption);

  exports.FeatureOptionStub = FeatureOptionStub;

  module.exports = exports;

}).call(this);

// Wrap_post.js, for features/feature_options
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/feature_options");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/feature_options");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/feature_options'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/feature_options as", modules['features/feature_options']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/feature
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/feature");

// Generated by CoffeeScript 1.4.0
(function() {
  var CPU_FEATURE_VAR, DumpObjectFlat, FEATURE_CLASS, FEATURE_NAME, Feature, Options, StackTrace, clone, decSymbol, exports, feature_cache, get_features, register_feature, vlog, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  vlog = require('verbosity').vlog;

  decSymbol = require('symbols').decSymbol;

  _ref = require('tc_util'), StackTrace = _ref.StackTrace, clone = _ref.clone, DumpObjectFlat = _ref.DumpObjectFlat;

  Options = require('features/feature_options');

  CPU_FEATURE_VAR = decSymbol('CPU_FEATURE_VAR', '_features');

  FEATURE_NAME = decSymbol('FEATURE_NAME', 'name');

  FEATURE_CLASS = decSymbol('FEATURE_CLASS', 'class');

  feature_cache = {};

  register_feature = function(name, feature) {
    if (__indexOf.call(feature_cache, name) >= 0 && feature_cache[name] !== feature) {
      throw "already registered";
    }
    return feature_cache[name] = feature;
  };

  get_features = function() {
    return clone(feature_cache);
  };

  Feature = (function() {

    function Feature(name) {
      this.name = name;
      this.options = {};
    }

    Feature.prototype.option = function(name, option) {
      if (this.options[name] != null) {
        console.log("option " + name + " already defined as", this.options[name], StackTrace());
        throw "option " + name + " already defined as " + (DumpObjectFlat(this.options[name]));
      }
      return this.options[name] = option;
    };

    Feature.prototype.get_options = function() {
      return clone(this.options);
    };

    Feature.prototype.has_feature = function(name, cpu) {
      return name in cpu[CPU_FEATURE_VAR];
    };

    Feature.prototype.get_feature = function(name, cpu) {
      return cpu[CPU_FEATURE_VAR][name];
    };

    Feature.prototype.get_features = function(cpu) {
      var feature, _results;
      _results = [];
      for (feature in cpu[CPU_FEATURE_VAR]) {
        _results.push(feature);
      }
      return _results;
    };

    Feature.prototype.read = function(loc, cpu, real_read) {
      return real_read.call(cpu, loc);
    };

    Feature.prototype.write = function(loc, value, cpu, real_write) {
      return real_write.call(cpu, loc, value);
    };

    Feature.prototype.interrupt = function(num, cpu) {
      return this.handle_interrupt(num, cpu);
    };

    Feature.prototype.handle_read = function(loc, cpu, real_read) {
      vlog(80, "handle_read(", [loc].join(', '), "): Feature dummy implementation");
      return real_read.call(cpu, loc);
    };

    Feature.prototype.handle_write = function(loc, value, cpu, real_write) {
      vlog(80, "handle_write(", [loc, value].join(', '), "): Feature dummy implementation");
      return real_write.call(cpu, loc, value);
    };

    Feature.prototype.handle_interrupt = function(num, cpu) {};

    Feature.prototype.load_into = function(cpu) {
      var name;
      vlog(10, "Loading", this.name, "into CPU instance");
      name = this.name;
      return (function(instance, feature) {
        return (function(initialize, read, write, interrupt) {
          if (!(instance[CPU_FEATURE_VAR] != null)) {
            instance[CPU_FEATURE_VAR] = {};
          }
          instance.initialize = function() {
            return feature.handle_initialize(instance, initialize);
          };
          instance.read = function(loc) {
            return feature.handle_read(loc, instance, read);
          };
          instance.write = function(loc, value) {
            return feature.handle_write(loc, value, instance, write);
          };
          instance.interrupt = function(num) {
            return feature.interrupt(num, instance);
          };
          instance[CPU_FEATURE_VAR][name] = feature;
          feature.handle_load_into(instance);
          return instance;
        })(instance.initialize, instance.read, instance.write, instance.interrupt);
      })(cpu, this);
    };

    Feature.prototype.handle_load_into = function(cpu) {};

    Feature.prototype.handle_initialize = function(cpu, real_initialize) {
      return real_initialize.call(cpu);
    };

    return Feature;

  })();

  decSymbol('Feature', Feature);

  exports = module.exports = {
    CPU_FEATURE_VAR: CPU_FEATURE_VAR,
    FEATURE_NAME: 'name',
    FEATURE_CLASS: FEATURE_CLASS,
    Feature: Feature,
    RegisterFeature: register_feature,
    GetFeatures: get_features,
    Options: Options
  };

  decSymbol('Feature.exports', exports);

}).call(this);

// Wrap_post.js, for features/feature
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/feature");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/feature");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/feature'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/feature as", modules['features/feature']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/dma
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/dma");

// Generated by CoffeeScript 1.4.0
(function() {
  var DEBUG, DMA, DMA_DISABLED, FEATURE_CLASS, FEATURE_DMA, FEATURE_NAME, Feature, Options, RegisterFeature, check_range, decSymbol, deregister_range, dma_ranges, exports, find_feature, register_range, vlog, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('features/feature'), Feature = _ref.Feature, FEATURE_NAME = _ref.FEATURE_NAME, FEATURE_CLASS = _ref.FEATURE_CLASS, RegisterFeature = _ref.RegisterFeature, Options = _ref.Options;

  vlog = require('verbosity').vlog;

  decSymbol = require('symbols').decSymbol;

  DEBUG = true;

  FEATURE_DMA = decSymbol('FEATURE_DMA', 'DMA');

  DMA_DISABLED = decSymbol('DMA_DISABLED', NaN);

  dma_ranges = [];

  check_range = function(start, end) {
    var tmp;
    if (start > end) {
      tmp = start;
      start = end;
      end = tmp;
    }
    return {
      start: start,
      end: end
    };
  };

  register_range = function(start, end, instance, dma_id) {
    var feature, _i, _len, _ref1;
    if (!instance) {
      throw "Instance required in register_range(" + start + ", " + end + ")";
    }
    _ref1 = check_range(start, end), start = _ref1.start, end = _ref1.end;
    for (_i = 0, _len = dma_ranges.length; _i < _len; _i++) {
      feature = dma_ranges[_i];
      if (feature.start >= start && feature.end >= start) {
        return false;
      }
    }
    dma_ranges.push({
      start: start,
      end: end,
      name: instance.name,
      instance: instance,
      id: dma_id
    });
    return true;
  };

  deregister_range = function(start, end) {
    var i, _ref1;
    if (!instance) {
      throw "Instance required in register_range(" + start + ", " + end + ")";
    }
    _ref1 = check_range(start, end), start = _ref1.start, end = _ref1.end;
    i = 0;
    while (i < dma_ranges.length) {
      if (feature.start >= start && feature.end >= start) {
        return dma_ranges.splice(i, 1);
      }
      i++;
    }
    return false;
  };

  find_feature = function(start) {
    var feature, _i, _len;
    for (_i = 0, _len = dma_ranges.length; _i < _len; _i++) {
      feature = dma_ranges[_i];
      if (feature.start >= start && feature.end < start) {
        feature;

      }
    }
    return null;
  };

  DMA = (function(_super) {

    __extends(DMA, _super);

    function DMA(options) {
      var feature, range, result;
      this.rangeStart = options.rangeStart, this.rangeEnd = options.rangeEnd, this.debug = options.debug, this.name = options.name, this.ranges = options.ranges;
      this.range_id_counter = 0;
      this.ranges = [];
      if (this.debug == null) {
        this.debug = DEBUG;
      }
      if (!this.name) {
        this.name = "generic DMA device";
      }
      DMA.__super__.constructor.call(this, this.name);
      range = this.option('range', new Options.IntegerRangeOption('range', this.rangeStart, this.rangeEnd));
      range.bind('set', function(range) {
        this.rangeStart = range[0], this.rangeEnd = range[1];
      });
      if (isNaN(this.rangeStart)) {
        if (isNaN(this.rangeEnd)) {
          this.ranges.pop();
          vlog(10, "device(" + this.name + ") registered with no current DMA range");
        } else {
          throw "DMA_DISABLED must be used for start and end";
        }
      } else {
        result = this.declare_range(this.rangeStart, this.rangeEnd);
        if (result === false) {
          feature = find_feature(this.rangeStart);
          throw "range in use by " + feature.name;
        }
      }
    }

    DMA.prototype.new_range = function(start, end) {
      return {
        start: Math.min(start, end),
        end: Math.max(start, end),
        id: this.range_id_counter++
      };
    };

    DMA.prototype.declare_range = function(start, end) {
      var range;
      range = this.new_range(start, end);
      if (!register_range(start, end, this, range.id)) {
        false;
      }
      this.ranges.push(range);
      vlog(10, "DMA device(" + this.name + ", " + range.start + " ... " + range.end + ") registered at " + range.id);
      return range.id;
    };

    DMA.prototype.remove_range = function(start, end) {
      var result;
      result = deregister_range(start, end);
      if (!result) {
        return false;
      }
      return result.id;
    };

    DMA.prototype.offset = function(loc) {
      return loc;
    };

    DMA.prototype.isInRange = function(loc) {
      var end, found, id, range, start, _i, _len, _ref1;
      vlog(70, this.name, " range is: ", this.ranges);
      _ref1 = this.ranges;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        range = _ref1[_i];
        start = range.start;
        end = range.end;
        id = range.id;
        found = false;
        if (start >= 0 && end >= 0) {
          vlog(80, "Comp1: loc(", loc, ") >= start(", start, ") && loc <= end(", end, ")");
          found = loc >= start && loc <= end;
        } else if (start <= 0 && end <= 0) {
          if (start > end) {
            vlog(80, "Comp2: loc(", loc, ") >= start(", start, ") && loc <= end(", end, ")");
            found = loc >= start && loc <= end;
          } else {
            vlog(80, "Comp3: loc(", loc, ") >= start(", start, ") && loc <= end(", end, ")");
            found = loc >= start && loc <= end;
          }
        } else {
          vlog(10, "Missing a comparison for " + start + " .. " + end);
        }
        if (found) {
          vlog(50, "Found matching entry at DMA id " + id + ", ranges: ", this.ranges);
          return {
            id: id
          };
        }
      }
      return false;
    };

    DMA.prototype.handle_read = function(loc, cpu, real_read) {
      var match, offset, result;
      match = this.isInRange(loc);
      if (match) {
        this.dma_id = match.id;
        offset = this.offset(loc);
        result = this.dma_read(offset, cpu);
      } else {
        offset = loc;
        result = real_read(loc);
      }
      vlog(70, ("dma_read(" + offset + ") = " + result) + (match ? " (dma handled by " + this.name + "." + match.id + ")" : " (not handled by " + this.name + ")"));
      return result;
    };

    DMA.prototype.handle_write = function(loc, value, cpu, real_write) {
      var match, offset, result;
      match = this.isInRange(loc);
      if (match) {
        this.dma_id = match.id;
        offset = this.offset(loc);
        result = this.dma_write(offset, value, cpu);
      } else {
        offset = loc;
        result = real_write(loc, value);
      }
      vlog(70, ("dma_write(" + offset + ", " + value + ") = " + result) + (match ? " (dma handled by " + this.name + "." + match.id + ")" : " (not handled by " + this.name + ")"));
      return result;
    };

    DMA.prototype.dma_read = function(loc, cpu) {
      vlog(30, 'WARN: Dummy dma_read in ', this.name);
      return 0;
    };

    DMA.prototype.dma_write = function(loc, value, cpu) {
      vlog(30, 'WARN: Dummy dma_write in ', this.name);
      return 0;
    };

    return DMA;

  })(Feature);

  decSymbol("DMA", DMA);

  RegisterFeature("DMA", DMA);

  exports = module.exports || {};

  exports[FEATURE_NAME] = FEATURE_DMA;

  exports[FEATURE_CLASS] = DMA;

  exports.register_feature = register_range;

  exports.find_feature = find_feature;

  exports.DMA_DISABLED = DMA_DISABLED;

  module.exports = exports;

  decSymbol("DMA.exports", exports);

}).call(this);

// Wrap_post.js, for features/dma
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/dma");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/dma");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/dma'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/dma as", modules['features/dma']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/buffer
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/buffer");

// Generated by CoffeeScript 1.4.0
(function() {
  var Buffer, decSymbol, vlog;

  vlog = require('verbosity').vlog;

  decSymbol = require('symbols').decSymbol;

  Buffer = (function() {

    function Buffer() {
      this.buffer = [];
      this.pos = 0;
    }

    Buffer.prototype.eof = function() {
      return this.pos === this.buffer.length;
    };

    Buffer.prototype.feof = function() {
      return this.eof();
    };

    Buffer.prototype.read = function() {
      var val;
      val = this.buffer[this.pos++];
      vlog(50, "Buffer.read() = ", val);
      this.rangecheck();
      return val;
    };

    Buffer.prototype.write = function(value) {
      vlog(50, "Buffer.write(", value, ")");
      return this._push(value);
    };

    Buffer.prototype.seek = function(offset, from) {
      this.pos = (function() {
        switch (from) {
          case SEEK_CURR:
            return pos + offset;
          case SEEK_START:
            return offset;
          case SEEK_END:
            return this.buffer.length + offset;
        }
      }).call(this);
      return this.rangecheck();
    };

    Buffer.prototype.rangecheck = function() {
      while (this.pos > this.buffer.length) {
        vlog(70, "Adjusting @pos from ", this.pos, " to ", this.pos - this.buffer.length);
        this.pos -= this.buffer.length;
      }
      return this.pos;
    };

    Buffer.prototype._push = function(value) {
      this.buffer.push(value);
      return value;
    };

    Buffer.prototype._pop = function() {
      return this.buffer.pop();
    };

    Buffer.prototype.flush = function(max, mapper, reducer) {
      var length, result, v;
      length = 0;
      result = [];
      mapper || (mapper = String.fromCharCode);
      reducer || (reducer = function(r) {
        return r.join('');
      });
      while (!this.eof() && (max ? length++ <= max : true)) {
        v = mapper(this.read());
        vlog(70, "Buffer.flush: got ", v);
        result.push(v);
      }
      return reducer(result);
    };

    return Buffer;

  })();

  decSymbol('Buffer', Buffer);

  exports.Buffer = Buffer;

  module.exports = exports;

  decSymbol('Buffer.exports', exports);

}).call(this);

// Wrap_post.js, for features/buffer
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/buffer");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/buffer");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/buffer'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/buffer as", modules['features/buffer']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/interrupts/interrupt
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/interrupts/interrupt");

// Generated by CoffeeScript 1.4.0
(function() {
  var DEFAULT_FREQ, FEATURE_CLASS, FEATURE_INT, FEATURE_NAME, FREQ_VAR, Feature, INTERRUPTS_VAR, Interrupt, LAST_VAR, Options, RegisterFeature, TIMER_VAR, decSymbol, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('features/feature'), Feature = _ref.Feature, FEATURE_NAME = _ref.FEATURE_NAME, FEATURE_CLASS = _ref.FEATURE_CLASS, RegisterFeature = _ref.RegisterFeature, Options = _ref.Options;

  decSymbol = require('symbols').decSymbol;

  FEATURE_INT = decSymbol('FEATURE_INT', 'interrupt');

  INTERRUPTS_VAR = decSymbol('INTERRUPTS_VAR', 'interrupts');

  TIMER_VAR = decSymbol('TIMER_VAR', 'interrupts_timer');

  FREQ_VAR = decSymbol('FREQ_VAR', 'interrupts_freq');

  LAST_VAR = decSymbol('LAST_VAR', 'interrupts_last_int');

  DEFAULT_FREQ = decSymbol('DEFAULT_FREQ', 500);

  Interrupt = (function(_super) {

    __extends(Interrupt, _super);

    function Interrupt(interrupt_number) {
      interrupt_number = interrupt_number || 0;
      this.number = interrupt_number;
      this.option(new Options.IntegerOption('interrupt_number', interrupt_number));
    }

    Interrupt.prototype.handle_load_into = function(cpu) {
      if (cpu[INTERRUPTS_VAR] == null) {
        this.initialize(cpu);
      }
    };

    Interrupt.prototype.initialize = function(cpu) {
      var feature;
      feature = this;
      cpu[INTERRUPTS_VAR] = [];
      cpu[TIMER_VAR] = 0;
      cpu[FREQ_VAR] = DEFAULT_FREQ;
      cpu[LAST_VAR] = feature.timestamp();
      cpu.handle_interrupts = function() {
        return feature.handle_interrupts(cpu);
      };
      (function(real_cycle) {
        return cpu.cycle = function() {
          var timestamp;
          timestamp = feature.timestamp();
          if (timestamp - this[LAST_VAR] >= this[FREQ_VAR]) {
            this[TIMER_VAR]++;
            this.handle_interrupts();
            this[LAST_VAR] = feature.timestamp();
          }
          return real_cycle();
        };
      })(cpu.cycle);
    };

    Interrupt.prototype.timestamp = function() {
      return (new Date).getTime();
    };

    Interrupt.prototype.handle_interrupts = function(cpu) {};

    return Interrupt;

  })(Feature);

  exports.Interrupt = Interrupt;

  RegisterFeature('Interrupt', Interrupt);

  decSymbol('Interrupt', Interrupt);

  module.exports = exports;

}).call(this);

// Wrap_post.js, for features/interrupts/interrupt
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/interrupts/interrupt");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/interrupts/interrupt");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/interrupts/interrupt'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/interrupts/interrupt as", modules['features/interrupts/interrupt']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/io/bitmask
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/io/bitmask");

// Generated by CoffeeScript 1.4.0
(function() {
  var BITMASK_MASK, BITMASK_OP, BITMASK_OP_AND, BITMASK_OP_NONE, BITMASK_OP_NOT, BITMASK_OP_OR, BITMASK_OP_SHLEFT, BITMASK_OP_SHRIGHT, BITMASK_OP_XOR, BITMASK_RANGE, BITMASK_RESULT, BITMASK_VALUE, Bitmask, Buffer, DMA, FEATURE_BITMASK, decSymbol, dma, exports, feature, vlog,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  feature = require('features/feature');

  dma = require('features/dma');

  Buffer = require('features/buffer').Buffer;

  vlog = require('verbosity').vlog;

  decSymbol = require('symbols').decSymbol;

  DMA = dma[feature.FEATURE_CLASS];

  FEATURE_BITMASK = decSymbol('FEATURE_BITMASK', 'bitmask');

  BITMASK_MASK = decSymbol('BITMASK_MASK', -20);

  BITMASK_OP = decSymbol('BITMASK_OP', -21);

  BITMASK_VALUE = decSymbol('BITMASK_VALUE', -22);

  BITMASK_RESULT = decSymbol('BITMASK_RESULT', -23);

  BITMASK_RANGE = decSymbol('BITMASK_RANGE', [-20, -23]);

  BITMASK_OP_NONE = decSymbol('BITMASK_OP_NONE', 0);

  BITMASK_OP_OR = decSymbol('BITMASK_OP_OR', 1);

  BITMASK_OP_AND = decSymbol('BITMASK_OP_AND', 2);

  BITMASK_OP_NOT = decSymbol('BITMASK_OP_NOT', 3);

  BITMASK_OP_XOR = decSymbol('BITMASK_OP_XOR', 10);

  BITMASK_OP_SHLEFT = decSymbol('BITMASK_OP_SHLEFT', 30);

  BITMASK_OP_SHRIGHT = decSymbol('BITMASK_OP_SHRIGHT', 40);

  Bitmask = (function(_super) {

    __extends(Bitmask, _super);

    function Bitmask(flush_callback) {
      this.bitmask_mask = 0;
      this.bitmask_op = BITMASK_OP_NONE;
      this.bitmask_value = 0;
      this.bitmask_result = 0;
      Bitmask.__super__.constructor.call(this, {
        name: "bitmask",
        rangeStart: BITMASK_RANGE[0],
        rangeEnd: BITMASK_RANGE[1]
      });
    }

    Bitmask.prototype.recalculate = function() {
      var mask, value;
      mask = this.bitmask_mask;
      value = this.bitmask_value;
      return this.bitmask_result = (function() {
        switch (this.bitmask_op) {
          case BITMASK_OP_NONE:
            return 0;
          case BITMASK_OP_OR:
            return value | mask;
          case BITMASK_OP_AND:
            return value & mask;
          case BITMASK_OP_NOT:
            return ~value;
          case BITMASK_OP_XOR:
            return value ^ mask;
          case BITMASK_OP_SHLEFT:
            return value << mask;
          case BITMASK_OP_SHRIGHT:
            return value >> mask;
        }
      }).call(this);
    };

    Bitmask.prototype.dma_read = function(loc, cpu) {
      var result;
      result = (function() {
        switch (loc) {
          case BITMASK_MASK:
            return this.bitmask_mask;
          case BITMASK_OP:
            return this.bitmask_op;
          case BITMASK_VALUE:
            return this.bitmask_value;
          case BITMASK_RESULT:
            return this.bitmask_result;
        }
      }).call(this);
      vlog(70, "bitmask.dma_read(", loc, ")");
      return result;
    };

    Bitmask.prototype.dma_write = function(loc, value, cpu) {
      var result;
      result = (function() {
        switch (loc) {
          case BITMASK_MASK:
            return this.bitmask_mask = value;
          case BITMASK_OP:
            return this.bitmask_op = value;
          case BITMASK_VALUE:
            return this.bitmask_value = value;
          case BITMASK_RESULT:
            return 0;
        }
      }).call(this);
      this.recalculate();
      vlog(70, "bitmask.dma_write(", loc, ",", value, ")");
      return result;
    };

    return Bitmask;

  })(DMA);

  decSymbol('Bitmask', Bitmask);

  feature.RegisterFeature('IO/Bitmask', Bitmask);

  exports = module.exports = {
    BITMASK_MASK: BITMASK_MASK,
    BITMASK_OP: BITMASK_OP,
    BITMASK_VALUE: BITMASK_VALUE,
    BITMASK_RESULT: BITMASK_RESULT,
    BITMASK_RANGE: BITMASK_RANGE,
    BITMASK_OP_NONE: BITMASK_OP_NONE,
    BITMASK_OP_OR: BITMASK_OP_OR,
    BITMASK_OP_AND: BITMASK_OP_AND,
    BITMASK_OP_NOT: BITMASK_OP_NOT,
    BITMASK_OP_XOR: BITMASK_OP_XOR,
    BITMASK_OP_SHLEFT: BITMASK_OP_SHLEFT,
    BITMASK_OP_SHRIGHT: BITMASK_OP_SHRIGHT,
    Bitmask: Bitmask
  };

  exports[feature.FEATURE_NAME] = FEATURE_BITMASK;

  exports[feature.FEATURE_CLASS] = Bitmask;

  decSymbol('Bitmask.exports', exports);

}).call(this);

// Wrap_post.js, for features/io/bitmask
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/io/bitmask");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/io/bitmask");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/io/bitmask'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/io/bitmask as", modules['features/io/bitmask']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/io/stdio
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/io/stdio");

// Generated by CoffeeScript 1.4.0
(function() {
  var Buffer, DMA, FEATURE_STDIO, SEEK_CURR, SEEK_END, SEEK_START, STDIO_CHANNEL, STDIO_ERR, STDIO_FEOF, STDIO_FLUSH, STDIO_FSEEK, STDIO_FSEEK_FROM, STDIO_IN, STDIO_MAGIC, STDIO_MAGIC_MAGIC, STDIO_OUT, STDIO_RANGE, STDIO_READ, STDIO_WRITE, Stdio, decSymbol, dma, exports, feature, vlog,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  feature = require('features/feature');

  dma = require('features/dma');

  Buffer = require('features/buffer').Buffer;

  vlog = require('verbosity').vlog;

  decSymbol = require('symbols').decSymbol;

  DMA = dma[feature.FEATURE_CLASS];

  FEATURE_STDIO = decSymbol('FEATURE_STDIO', 'stdio');

  STDIO_MAGIC_MAGIC = decSymbol('STDIO_MAGIC_MAGIC', 0xDEADBEEF01);

  STDIO_MAGIC = decSymbol('STDIO_MAGIC', -4);

  STDIO_CHANNEL = decSymbol('STDIO_CHANNEL', -5);

  STDIO_FEOF = decSymbol('STDIO_FEOF', -6);

  STDIO_FSEEK = decSymbol('STDIO_FSEEK', -7);

  STDIO_FSEEK_FROM = decSymbol('STDIO_FSEEK_FROM', -8);

  STDIO_READ = decSymbol('STDIO_READ', -9);

  STDIO_WRITE = decSymbol('STDIO_WRITE', -10);

  STDIO_RANGE = decSymbol('STDIO_RANGE', [-10, -4]);

  STDIO_IN = decSymbol('STDIO_IN', 0);

  STDIO_OUT = decSymbol('STDIO_OUT', 1);

  STDIO_ERR = decSymbol('STDIO_ERR', 2);

  STDIO_FLUSH = decSymbol('STDIO_FLUSH', 11);

  SEEK_CURR = decSymbol('SEEK_CURR', 0);

  SEEK_START = decSymbol('SEEK_START', 1);

  SEEK_END = decSymbol('SEEK_END', 2);

  Stdio = (function(_super) {

    __extends(Stdio, _super);

    function Stdio(flush_callback) {
      this.buffer_stdin = new Buffer;
      this.buffer_stdout = new Buffer;
      this.buffer_stderr = new Buffer;
      this.buffers = [this.buffer_stdin, this.buffer_stdout, this.buffer_stderr];
      this.buffer_index = 0;
      this.buffer = this.buffers[this.buffer_index];
      this.fseek_from = SEEK_CURR;
      this.flush_callback = flush_callback;
      Stdio.__super__.constructor.call(this, {
        name: "standard io",
        rangeStart: STDIO_RANGE[0],
        rangeEnd: STDIO_RANGE[1]
      });
      this.option('flush_callback', new feature.Options.FeatureOptionStub('flush_callback', flush_callback));
    }

    Stdio.prototype.dma_read = function(loc, cpu) {
      var result;
      result = (function() {
        switch (loc) {
          case STDIO_MAGIC:
            return STDIO_MAGIC_MAGIC;
          case STDIO_CHANNEL:
            return this.buffer_index;
          case STDIO_FEOF:
            return this.buffer.feof();
          case STDIO_FSEEK:
            return 0;
          case STDIO_FSEEK_FROM:
            return this.fseek_from;
          case STDIO_READ:
            return this.buffer.read();
          case STDIO_WRITE:
            return 0;
        }
      }).call(this);
      vlog(70, "io.dma_read(", loc, ")");
      return result;
    };

    Stdio.prototype.dma_write = function(loc, value, cpu) {
      var result;
      result = (function() {
        switch (loc) {
          case STDIO_MAGIC:
            return 0;
          case STDIO_CHANNEL:
            return this.switch_buffer(value);
          case STDIO_FEOF:
            return 0;
          case STDIO_FSEEK:
            vlog(20, "STDIO.fseek(", value, ", ", this.fseek_from, ")");
            return this.buffer.fseek(value, this.fseek_from);
          case STDIO_FSEEK_FROM:
            vlog(20, "STDIO.fseek_from(", value, ")");
            return this.fseek_from = value;
          case STDIO_READ:
            return 0;
          case STDIO_WRITE:
            vlog(20, "STDIO.write(", value, ")");
            return this.buffer.write(value);
        }
      }).call(this);
      vlog(70, "io.dma_write(", loc, ",", value, ")");
      return result;
    };

    Stdio.prototype.switch_buffer = function(buffer) {
      if (buffer >= 0 && buffer < this.buffers.length) {
        this.buffer = this.buffers[this.buffer_index = buffer];
        vlog(30, "STDIO.switch_buffer(", buffer, ")");
        return buffer;
      } else if (buffer === STDIO_FLUSH) {
        return this.handle_flush();
      } else {
        throw "stdio: switch_buffer(" + buffer + "): invalid buffer";
      }
    };

    Stdio.prototype.push_to_buffer = function(contents, buffer_id) {
      var char, old, _i, _len;
      old = this.buffer_index;
      this.switch_buffer(buffer_id);
      for (_i = 0, _len = contents.length; _i < _len; _i++) {
        char = contents[_i];
        this.buffer.write(char);
      }
      this.buffer_index = old;
      this.switch_buffer(this.buffer_index);
      return contents.length;
    };

    Stdio.prototype.handle_flush = function() {
      vlog(50, "STDIO.flush(), calling callback: ", this.flush_callback);
      this.flush_callback(this.buffer_index, this.buffer);
      return this.buffer_index;
    };

    return Stdio;

  })(DMA);

  decSymbol('Stdio', Stdio);

  feature.RegisterFeature('IO/stdio', Stdio);

  exports = module.exports = {
    STDIO_CHANNEL: STDIO_CHANNEL,
    STDIO_FEOF: STDIO_FEOF,
    STDIO_FSEEK: STDIO_FSEEK,
    STDIO_FSEEK_FROM: STDIO_FSEEK_FROM,
    STDIO_READ: STDIO_READ,
    STDIO_WRITE: STDIO_WRITE,
    STDIO_IN: STDIO_IN,
    STDIO_OUT: STDIO_OUT,
    STDIO_ERR: STDIO_ERR,
    STDIO_FLUSH: STDIO_FLUSH,
    SEEK_CURR: SEEK_CURR,
    SEEK_START: SEEK_START,
    SEEK_END: SEEK_END,
    Stdio: Stdio
  };

  exports[feature.FEATURE_NAME] = FEATURE_STDIO;

  exports[feature.FEATURE_CLASS] = Stdio;

  decSymbol('Stdio.exports', exports);

}).call(this);

// Wrap_post.js, for features/io/stdio
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/io/stdio");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/io/stdio");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/io/stdio'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/io/stdio as", modules['features/io/stdio']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/mm/support/pages
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/mm/support/pages");

// Generated by CoffeeScript 1.4.0
(function() {
  var PAGE_DEFAULT_SIZE, Page, PageImplementation, PageImplementations, PagingNode, PagingOptions, clone, decSymbol, options, vlog;

  vlog = require('verbosity').vlog;

  decSymbol = require('symbols').decSymbol;

  clone = require('tc_util').clone;

  PAGE_DEFAULT_SIZE = decSymbol('PAGE_DEFAULT_SIZE', 32 * 1024);

  PageImplementation = (function() {

    function PageImplementation() {
      this.init();
    }

    PageImplementation.prototype.read = function(location) {
      return this.do_read(location);
    };

    PageImplementation.prototype.write = function(location, value) {
      return this.do_write(location, value);
    };

    PageImplementation.prototype.init = function() {
      vlog(50, 'PageImplementation.init: base implementation');
      return this.memory = {};
    };

    PageImplementation.prototype.do_read = function(location) {
      vlog(50, 'PageImplementation.do_read: base implementation');
      return this.memory[location] || 0;
    };

    PageImplementation.prototype.do_write = function(location, value) {
      vlog(50, 'PageImplementation.do_write: base implementation');
      return this.memory[location] = value || 0;
    };

    return PageImplementation;

  })();

  PageImplementations = {};

  exports.RegisterPageImplementation = function(name, cls) {
    return PageImplementations[name] = cls;
  };

  exports.GetPageImplementations = function() {
    return clone(PageImplementations);
  };

  exports.RegisterPageImplementation('Default', PageImplementation);

  PagingOptions = (function() {

    function PagingOptions(Options) {
      Options = Options || {};
      this.PageSize = Options.PageSize || PAGE_DEFAULT_SIZE;
      this.PageImplementation = 'Default';
    }

    PagingOptions.prototype.getPageImplementation = function(name) {
      var x;
      x = PageImplementations[name || this.PageImplementation];
      return new x;
    };

    return PagingOptions;

  })();

  exports.PagingOptions = PagingOptions;

  Page = (function() {

    function Page(pageSize, implementation) {
      this.pageSize = pageSize || options.PageSize;
      this.implementation = options.getPageImplementation(implementation);
    }

    Page.prototype.read = function(location) {
      return this.implementation.read(location);
    };

    Page.prototype.write = function(location, value) {
      return this.implementation.write(location, value);
    };

    return Page;

  })();

  exports.Page = Page;

  PagingNode = (function() {

    function PagingNode(start, range, implementation) {
      this.start = start;
      this.range = range;
      this.implementation = implementation;
      this.prev = null;
      this.next = null;
      this.page = new Page(range, this.implementation);
    }

    PagingNode.prototype.read = function(location) {
      return this.page.read(location);
    };

    PagingNode.prototype.write = function(location, value) {
      return this.page.write(location, value);
    };

    return PagingNode;

  })();

  exports.PagingNode = PagingNode;

  options = new PagingOptions;

  exports.options = options;

  module.exports = exports;

  decSymbol('Paging.support.pages', exports);

}).call(this);

// Wrap_post.js, for features/mm/support/pages
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/mm/support/pages");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/mm/support/pages");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/mm/support/pages'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/mm/support/pages as", modules['features/mm/support/pages']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/mm/paging
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/mm/paging");

// Generated by CoffeeScript 1.4.0
(function() {
  var DMA, DMA_DISABLED, FEATURE_CLASS, FEATURE_NAME, PGSTATS_PAGES_ALLOCATED, PageTest, Pages, Paging, clone, decSymbol, dma, feature, key, value, vlog,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  decSymbol = require('symbols').decSymbol;

  feature = require('features/feature');

  dma = require('features/dma');

  vlog = require('verbosity').vlog;

  clone = require('tc_util').clone;

  Pages = require('features/mm/support/pages');

  DMA = dma[feature.FEATURE_CLASS];

  DMA_DISABLED = dma.DMA_DISABLED;

  FEATURE_NAME = feature.FEATURE_NAME, FEATURE_CLASS = feature.FEATURE_CLASS;

  PGSTATS_PAGES_ALLOCATED = decSymbol('PGSTATS_PAGES_ALLOCATED', 'pages_allocated');

  for (key in Pages) {
    value = Pages[key];
    exports[key] = value;
  }

  Paging = (function(_super) {

    __extends(Paging, _super);

    function Paging(Options) {
      var range;
      Options = Options || {};
      this.pageSize = Options.pageSize, this.implementation = Options.implementation;
      this.pageSize = this.pageSize || Pages.options.PageSize;
      this.implementation = this.implementation || Pages.options.PageImplementation;
      this.stats = {};
      this.head = this.allocate(0);
      this.stat(PGSTATS_PAGES_ALLOCATED, 1);
      Paging.__super__.constructor.call(this, {
        rangeStart: DMA_DISABLED,
        rangeEnd: DMA_DISABLED,
        name: "Paging"
      });
      range = this.option('ranges', new feature.Options.FeatureOptionStub('ranges', []));
    }

    Paging.prototype.read = function(location) {
      this.reset_head(location);
      return this.head.read(location - this.head.start);
    };

    Paging.prototype.write = function(location, value) {
      this.reset_head(location);
      return this.head.write(location - this.head.start, value);
    };

    Paging.prototype.get_stats = function() {
      return clone(this.stats);
    };

    Paging.prototype.page_range = function(start, end) {
      var dma_range_id;
      dma_range_id = this.declare_range(start, end);
      if (!dma_range_id) {
        return false;
      }
      return dma_range_id;
    };

    Paging.prototype.unpage_range = function(start, end) {
      var dma_range_id;
      dma_range_id = this.remove_range(start, end);
      if (!dma_range_id) {
        return false;
      }
      return dma_range_id;
    };

    Paging.prototype.stat = function(stat, increment) {
      this.stats[stat] = this.stats[stat] || 0;
      return this.stats[stat] += increment;
    };

    Paging.prototype.reset_head = function(location) {
      return this.head = this.select(location, this.head);
    };

    Paging.prototype.select = function(location, PagingNode) {
      if (location >= PagingNode.start && location <= PagingNode.start + PagingNode.range) {
        return PagingNode;
      } else if (location < PagingNode.start) {
        if (!PagingNode.prev || location > (PagingNode.prev.start + PagingNode.prev.range)) {
          this.allocate(location, PagingNode);
        }
        return this.select(location, PagingNode.prev);
      } else {
        if (!PagingNode.next || location < PagingNode.next.start) {
          this.allocate(location, PagingNode);
        }
        return this.select(location, PagingNode.next);
      }
    };

    Paging.prototype.allocate = function(location, FromNode) {
      var node;
      node = new Pages.PagingNode(this.align(location), this.pageSize, this.implementation);
      this.stat(PGSTATS_PAGES_ALLOCATED, +1);
      if (!FromNode) {
        return node;
      }
      if (location < FromNode.start) {
        node.next = FromNode;
        node.prev = FromNode.prev;
        FromNode.prev = node;
      } else {
        node.next = FromNode.next;
        node.prev = FromNode;
        FromNode.next = node;
      }
      return node;
    };

    Paging.prototype.align = function(offset) {
      var sign;
      sign = 0;
      if (offset < 0) {
        sign = -1;
        offset = -offset;
      }
      if (offset % this.pageSize !== 0) {
        offset -= offset % this.pageSize;
      }
      if (sign) {
        return -offset - this.pageSize;
      }
      return offset;
    };

    Paging.prototype.dma_read = function(loc, cpu) {
      var result;
      result = this.read(loc);
      vlog(70, "Paging.lanes[" + this.dma_id + "].dma_read(" + loc + ") = " + result);
      return result;
    };

    Paging.prototype.dma_write = function(loc, value, cpu) {
      var result;
      result = this.write(loc, value);
      vlog(70, "Paging.lanes[" + this.dma_id + "].dma_write(" + loc + ", " + value + ") = " + result);
      return result;
    };

    return Paging;

  })(DMA);

  exports.Paging = Paging;

  decSymbol('Paging', Paging);

  feature.RegisterFeature('MM/paging', Paging);

  PageTest = function() {
    var charCode, offset, paging, stats;
    charCode = require('tc_util').charCode;
    offset = 0xFF;
    paging = new Paging;
    while (offset < 0xFFFFFFFF) {
      paging.write(offset + 0, charCode('H'));
      paging.write(offset + 1, charCode('e'));
      paging.write(offset + 2, charCode('l'));
      paging.write(offset + 3, charCode('l'));
      paging.write(offset + 4, charCode('o'));
      if (paging.read(offset + 0) !== charCode('H') || paging.read(offset + 1) !== charCode('e') || paging.read(offset + 2) !== charCode('l') || paging.read(offset + 3) !== charCode('l') || paging.read(offset + 4) !== charCode('o')) {
        return "failure at " + offset;
      }
      offset *= 10;
    }
    offset = -0xFF;
    while (offset > -0xFFFFFF) {
      paging.write(offset + 0, charCode('H'));
      paging.write(offset + 1, charCode('e'));
      paging.write(offset + 2, charCode('l'));
      paging.write(offset + 3, charCode('l'));
      paging.write(offset + 4, charCode('o'));
      if (paging.read(offset + 0) !== charCode('H') || paging.read(offset + 1) !== charCode('e') || paging.read(offset + 2) !== charCode('l') || paging.read(offset + 3) !== charCode('l') || paging.read(offset + 4) !== charCode('o')) {
        return "failure at " + offset;
      }
      offset *= 10;
    }
    stats = paging.get_stats();
    console.log("Pages allocated: ", stats[PGSTATS_PAGES_ALLOCATED]);
    return 'pass';
  };

  if (process.env.TCPU_PAGE_TEST) {
    console.log("Paging test: ", PageTest());
  }

  module.exports = exports;

}).call(this);

// Wrap_post.js, for features/mm/paging
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/mm/paging");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/mm/paging");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/mm/paging'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/mm/paging as", modules['features/mm/paging']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/watchers/flags
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/watchers/flags");

// Generated by CoffeeScript 1.4.0
(function() {
  var FEATURE_CLASS, FEATURE_FLAGS, FEATURE_NAME, Feature, Flags, RegisterFeature, decSymbol, vlog, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('features/feature'), Feature = _ref.Feature, FEATURE_NAME = _ref.FEATURE_NAME, FEATURE_CLASS = _ref.FEATURE_CLASS, RegisterFeature = _ref.RegisterFeature;

  vlog = require('verbosity').vlog;

  decSymbol = require('symbols').decSymbol;

  FEATURE_FLAGS = decSymbol('FEATURE_FLAGS', 'flags');

  Flags = (function(_super) {

    __extends(Flags, _super);

    function Flags() {
      Flags.__super__.constructor.call(this, FEATURE_FLAGS);
    }

    Flags.prototype.handle_load_into = function(cpu) {
      var feature;
      feature = this;
      return (function(update_flags) {
        return cpu.update_flags = function(sp, val) {
          return feature.handle_update_flags(sp, val, cpu, update_flags);
        };
      })(cpu.update_flags);
    };

    Flags.prototype.handle_initialize = function(cpu, real_initialize) {
      vlog(100, 'Flags initialize');
      Flags.__super__.handle_initialize.call(this, cpu, real_initialize);
      this.flags = cpu.flags = cpu.defReg('flags');
      return cpu.write(this.flags, 0x01);
    };

    Flags.prototype.handle_update_flags = function(sp, val, cpu, real_update_flags) {
      var flags;
      flags = cpu.read(sp + this.flags);
      vlog(30, "Flags is " + flags);
      if (flags & 0x01) {
        vlog(30, "Flags updating");
        real_update_flags.call(cpu, sp, val);
      }
      return val;
    };

    return Flags;

  })(Feature);

  decSymbol('Flags', Flags);

  RegisterFeature('Watchers/Flags', Flags);

  exports.Flags = Flags;

  exports[FEATURE_NAME] = FEATURE_FLAGS;

  exports[FEATURE_CLASS] = Flags;

  module.exports = exports;

  decSymbol('Flags.exports', exports);

}).call(this);

// Wrap_post.js, for features/watchers/flags
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/watchers/flags");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/watchers/flags");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/watchers/flags'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/watchers/flags as", modules['features/watchers/flags']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for features/watchers/halt
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for features/watchers/halt");

// Generated by CoffeeScript 1.4.0
(function() {
  var FEATURE_CLASS, FEATURE_HALT, FEATURE_NAME, Feature, HALTED_VAR, Halt, Options, RegisterFeature, decSymbol, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('features/feature'), Feature = _ref.Feature, FEATURE_NAME = _ref.FEATURE_NAME, FEATURE_CLASS = _ref.FEATURE_CLASS, RegisterFeature = _ref.RegisterFeature, Options = _ref.Options;

  decSymbol = require('symbols').decSymbol;

  FEATURE_HALT = decSymbol('FEATURE_HALT', 'halt');

  HALTED_VAR = decSymbol('HALTED_VAR', 'halted');

  Halt = (function(_super) {

    __extends(Halt, _super);

    function Halt(halt_callback) {
      this.halt_callback = halt_callback;
      Halt.__super__.constructor.call(this, FEATURE_HALT);
      this.option('halt_callback', new Options.FeatureOptionStub('halt_callback', halt_callback));
    }

    Halt.prototype.handle_load_into = function(cpu) {
      var feature;
      feature = this;
      return (function(real_execute) {
        cpu[HALTED_VAR] = false;
        cpu.execute = function(sp, src, add, dst) {
          if (arguments.length !== 4) {
            this.execute = real_execute;
            return this.execute.apply(this, arguments);
          } else if (this[HALTED_VAR]) {
            return 0;
          } else if (src === this.abs0 && add === 0 && dst === this.cp) {
            this[HALTED_VAR] = true;
            if (feature.halt_callback != null) {
              feature.halt_callback(this);
            }
            return 0;
          } else {
            return real_execute.call(cpu, sp, src, add, dst);
          }
        };
      })(cpu.execute);
    };

    return Halt;

  })(Feature);

  decSymbol('Halt', Halt);

  RegisterFeature('Watchers/Halt', Halt);

  exports.Halt = Halt;

  exports[FEATURE_NAME] = FEATURE_HALT;

  exports[FEATURE_CLASS] = Halt;

  module.exports = exports;

  decSymbol('Halt.exports', exports);

}).call(this);

// Wrap_post.js, for features/watchers/halt
	return exports;
});

if( modules ) {
	if (0) console.log("Registering features/watchers/halt");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from features/watchers/halt");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['features/watchers/halt'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered features/watchers/halt as", modules['features/watchers/halt']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for tests/features
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for tests/features");

// Generated by CoffeeScript 1.4.0
(function() {
  var Bitmask, Buffer, Feature, Flags, GetFeatures, Halt, Paging, STDIO_CHANNEL, STDIO_ERR, STDIO_FEOF, STDIO_FLUSH, STDIO_IN, STDIO_OUT, STDIO_READ, STDIO_WRITE, Stdio, TinyCPU, charCode, exports, symbols, test, vlog, _ref, _ref1,
    __hasProp = {}.hasOwnProperty;

  require('coffee-script/register');

  _ref = require('features/feature'), Feature = _ref.Feature, GetFeatures = _ref.GetFeatures;

  Halt = require('features/watchers/halt').Halt;

  Flags = require('features/watchers/flags').Flags;

  _ref1 = require('features/io/stdio'), Stdio = _ref1.Stdio, Buffer = _ref1.Buffer, STDIO_OUT = _ref1.STDIO_OUT, STDIO_CHANNEL = _ref1.STDIO_CHANNEL, STDIO_READ = _ref1.STDIO_READ, STDIO_WRITE = _ref1.STDIO_WRITE, STDIO_FLUSH = _ref1.STDIO_FLUSH, STDIO_FEOF = _ref1.STDIO_FEOF, STDIO_IN = _ref1.STDIO_IN, STDIO_ERR = _ref1.STDIO_ERR;

  TinyCPU = require('tinycpu').TinyCPU;

  vlog = require('verbosity').vlog;

  symbols = require('symbols');

  charCode = require('tc_util').charCode;

  Paging = require('features/mm/paging').Paging;

  Bitmask = require('features/io/bitmask').Bitmask;

  test = (function() {
    var abs0, ac, bitmask, code2, cp, cpu, cycle, cycles, flags, halted, hello, name, paging, r1, r2, stdio, writeString, _ref2, _ref3;
    console.log("The available features are: ", (function() {
      var _ref2, _results;
      _ref2 = GetFeatures();
      _results = [];
      for (name in _ref2) {
        if (!__hasProp.call(_ref2, name)) continue;
        _results.push(name);
      }
      return _results;
    })());
    vlog(50, "TinyCPU", TinyCPU);
    cpu = new TinyCPU;
    cpu.enable_debug(true);
    halted = false;
    (new Halt(function() {
      return halted = true;
    })).load_into(cpu);
    (new Flags).load_into(cpu);
    stdio = new Stdio(function(buffer_index, buffer) {
      var content, stream;
      stream = (function() {
        switch (buffer_index) {
          case STDIO_IN:
            return "stdin";
          case STDIO_OUT:
            return "stdout";
          case STDIO_ERR:
            return "stderr";
        }
      })();
      content = buffer.flush();
      console.log("(" + stream + ") " + content);
    });
    stdio.load_into(cpu);
    paging = false;
    paging = new Paging;
    paging.load_into(cpu);
    if (paging) {
      paging.page_range(0, 500);
    }
    bitmask = new Bitmask;
    bitmask.load_into(cpu);
    vlog(30, stdio.get_features(cpu).join(', '), 'loaded into test CPU');
    cpu.initialize();
    _ref2 = cpu.registers, abs0 = _ref2.abs0, cp = _ref2.cp, ac = _ref2.ac, flags = _ref2.flags, r1 = _ref2.r1, r2 = _ref2.r2;
    hello = [abs0, STDIO_OUT, STDIO_CHANNEL, abs0, charCode('H'), STDIO_WRITE, abs0, charCode('e'), STDIO_WRITE, abs0, charCode('l'), STDIO_WRITE, abs0, charCode('l'), STDIO_WRITE, abs0, charCode('o'), STDIO_WRITE, abs0, charCode(','), STDIO_WRITE, abs0, charCode(' '), STDIO_WRITE, abs0, charCode('w'), STDIO_WRITE, abs0, charCode('o'), STDIO_WRITE, abs0, charCode('r'), STDIO_WRITE, abs0, charCode('l'), STDIO_WRITE, abs0, charCode('d'), STDIO_WRITE, abs0, charCode('!'), STDIO_WRITE, abs0, STDIO_FLUSH, STDIO_CHANNEL, abs0, STDIO_IN, STDIO_CHANNEL, STDIO_FEOF, 0, r1, abs0, 0x01, flags, 0, 0, ac, r1, 0, r1, 0, 48, r2, ac, 0, r1, abs0, STDIO_OUT, STDIO_CHANNEL, r1, 0, STDIO_WRITE, abs0, STDIO_FLUSH, STDIO_CHANNEL, abs0, 0x0, flags, abs0, 0, cp];
    vlog(50, "Code: [", hello.join(', '), "]");
    cpu.write(flags, 0x00);
    cpu.load(100, hello);
    cpu.write(cp, 100);
    if (0) {
      code2 = [abs0, STDIO_IN, STDIO_CHANNEL, STDIO_READ, 0, r1, abs0, STDIO_OUT, STDIO_CHANNEL];
      writeString = function(string) {
        var char, code, _i, _len;
        code = [];
        for (_i = 0, _len = string.length; _i < _len; _i++) {
          char = string[_i];
          code = code.concat([abs0, charCode(char), STDIO_WRITE]);
        }
        return code;
      };
      code2 = code2.concat(writeString("This should be 'A': "));
      code2 = code2.concat([r1, 0, STDIO_WRITE, abs0, STDIO_FLUSH, STDIO_CHANNEL, abs0, 0, cp]);
      cpu.write(flags, 0x01);
      cpu.load(100, code2);
      cpu.write(cp, 100);
      stdio.push_to_buffer([charCode('A'), charCode('B')], STDIO_IN);
    }
    if (process.platform === 'browser') {
      cycle = function() {
        if (halted) {
          return vlog("20", "CPU halted, loop ending");
        } else {
          cpu.cycle();
          return setTimeout(cycle, 1);
        }
      };
      vlog(20, "Starting browser loop");
      return cycle();
    } else {
      cycles = -1;
      while (halted === false && ((_ref3 = cycles === -1) != null ? _ref3 : {
          "true": cycles-- > 0
        })) {
        cpu.cycle();
      }
      return vlog(20, "CPU halted, quitting");
    }
  });

  exports = module.exports = {
    test: test
  };

  if (typeof modules === 'undefined') {
    exports.test();
  }

}).call(this);

// Wrap_post.js, for tests/features
	return exports;
});

if( modules ) {
	if (0) console.log("Registering tests/features");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from tests/features");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['tests/features'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered tests/features as", modules['tests/features']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// Wrap.js, for lib/concur
ref = (function(require, exports, module) {
	if (0) console.log("Creating ref for lib/concur");

// Generated by CoffeeScript 1.4.0
(function() {
  var ConcurProcess, ConcurStack, ConcurVEU;

  ConcurProcess = (function() {

    function ConcurProcess(Options) {
      this.lpid = Options.lpid, this.rpid = Options.rpid, this.init_module = Options.init_module, this.init_fun = Options.init_fun, this.init_args = Options.init_args;
      this.stack = [];
      this.stack.push(new ConcurStack({
        module: this.init_module,
        fun: this.init_fun,
        args: this.init_args,
        process: this
      }));
      this.messages = [];
      this.memory = {};
    }

    return ConcurProcess;

  })();

  ConcurStack = (function() {

    function ConcurStack(Options) {
      this.module = Options.module, this.fun = Options.fun, this.args = Options.args, this.process = Options.process, this.parent = Options.parent;
      this.state = {};
      this.cp = 0;
    }

    ConcurStack.prototype.duplicate = function() {
      var cs;
      cs = new ConcurStack;
      cs.module = this.module;
      cs.fun = this.fun;
      cs.args = this.args;
      cs.process = this.process;
      cs.state = this.state;
      cs.cp = this.cp;
      return cs;
    };

    return ConcurStack;

  })();

  ConcurVEU = (function() {

    function ConcurVEU() {}

    return ConcurVEU;

  })();

}).call(this);

// Wrap_post.js, for lib/concur
	return exports;
});

if( modules ) {
	if (0) console.log("Registering lib/concur");
	var namespace = {test:1};
	var ex = {ex: 1};
	var module = {mod: 1};
	var ex_obtain = function(path) {
		if (0) console.log("obtain from lib/concur");
		return obtain(path);
	};
	res = ref.call(namespace, ex_obtain, ex, module);
	if (0) console.log("Res is", res);
	modules['lib/concur'] = module.exports;
	if (0) console.log("Namespace is", namespace);
	if (0) console.log("Exports is", ex);
	if (0) console.log("Registered lib/concur as", modules['lib/concur']);
} else {
	if (0) console.log("Standard export");
	ref(require, exports);
}


// App wrapper post

var init_complete_time = +new Date();
var diff = init_complete_time - start_time;
if (0) console.log("\nApplication init complete, modules registered in ", diff, "ms");

// invoke the app
require('tests/features').test();
